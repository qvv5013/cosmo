import Bio.PDB
import MDAnalysis as mda
import PeptideBuilder
import numpy as np
from PeptideBuilder import Geometry
from mdtraj.utils.rotation import rotation_matrix_from_quaternion

__all__ = ['build_single_chain']


def tile_universe(original_universe: mda.core.universe.Universe, num_copies_x: int,
                  num_copies_y: int) -> mda.core.universe.Universe:
    """
    tile universe: load universe of single chain and then make num_copies_x * num_copies_y copy.

    Parameters
    ----------
    original_universe: Original universe which contains single chain
    num_copies_x: copy as x dimension
    num_copies_y: copy as y dimension

    Returns
    -------
    new_universe: universe contains num_copies_x * num_copies_y chains of original chain.

    """
    if num_copies_x <= 0 or num_copies_y <= 0:
        raise ValueError("num_copies_x and num_copies_y should be greater than 0")
    chain_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
                  'U', 'V', 'W', 'X', 'Y', 'Z']

    n_atoms = len(list(original_universe.atoms))
    print(f"number of atoms in model: {n_atoms}")
    copied = []
    for x in range(num_copies_x):
        for y in range(num_copies_y):
            u_ = original_universe.copy()
            move_by = np.array([x * 10, y * 10, 0])
            u_.atoms.translate(move_by)
            chain_id = [chain_list[(x * num_copies_x + y) % len(chain_list)] for _ in range(n_atoms)]
            u_.add_TopologyAttr('chainID', chain_id)
            u_.add_TopologyAttr('segid', [chain_list[(x * num_copies_x + y) % len(chain_list)]])
            copied.append(u_.atoms)

    new_universe = mda.Merge(*copied)
    new_box = np.max(new_universe.atoms.positions, axis=0) - np.min(new_universe.atoms.positions, axis=0)
    new_universe.dimensions = list(new_box) + [90] * 3
    return new_universe


def build_single_chain(filename='out.pdb', fasta=''):
    """
    Build protein structure from fasta sequence using peptidebuilder
    """
    geo = Geometry.geometry(fasta[0])
    geo.phi = -120
    geo.psi_im1 = 150

    structure = PeptideBuilder.initialize_res(geo)
    for residue in fasta[1:]:
        structure = PeptideBuilder.add_residue(structure, residue, geo.phi, geo.psi_im1)

    out = Bio.PDB.PDBIO()
    out.set_structure(structure)
    ca_coords = []
    for residue in out.structure.get_residues():
        atoms = residue.get_atoms()
        for atom in atoms:
            if atom.name == 'CA':
                ca_coords.append([atom.coord[0], atom.coord[1], atom.coord[2]])

    ca_coords = np.array(ca_coords)

    # collect coordinate of all atoms generated by PeptideBuilder
    xyz = []
    for atom in out.structure.get_atoms():
        xyz.append([atom.coord[0], atom.coord[1], atom.coord[2]])
    xyz = np.array(xyz)
    # get the vector made by CA atoms of the first and last residues, then translate the molecule to parallel to Z-axis
    v = ca_coords[-1] - ca_coords[0]
    u = np.array([0, 0, 1])
    a = np.cross(v, u)
    a = a / np.linalg.norm(a, keepdims=True)
    b = np.arccos(np.dot(v, u) / np.linalg.norm(v))
    quaternion = np.insert(np.sin(-b / 2).reshape(-1, 1) * a, 0, np.cos(-b / 2), axis=1)
    translated_coord = xyz - np.mean(xyz, axis=0)
    translated_coord = np.matmul(translated_coord, rotation_matrix_from_quaternion(quaternion))
    xyz = np.array(translated_coord[0])

    # translate molecule to the origin
    xyz -= np.min(xyz, axis=0)

    # replace coordinate generated by PeptideBuilder by new coordinate
    for i, atom in enumerate(structure.get_atoms()):
        atom.coord = xyz[i]

    out.set_structure(structure)
    out.save(f"{filename}")
